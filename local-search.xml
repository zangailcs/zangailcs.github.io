<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Mybatis笔记03</title>
    <link href="/2022/06/14/Mybatis03/"/>
    <url>/2022/06/14/Mybatis03/</url>
    
    <content type="html"><![CDATA[<h3 id="mybatis笔记03">Mybatis笔记03</h3><h4 id="日志">1. 日志</h4><h5 id="日志工厂">1.1 日志工厂</h5><p>如果</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis笔记01</title>
    <link href="/2022/06/12/Mybatis01/"/>
    <url>/2022/06/12/Mybatis01/</url>
    
    <content type="html"><![CDATA[<h3 id="mybatis笔记01">Mybatis笔记01</h3><h4 id="获取mybatis">获取Mybatis</h4><ul><li>maven仓库</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>github: https://github.com/mybatis/mybatis-3/releases</li><li>中文文档：https://mybatis.org/mybatis-3/zh/index.html</li></ul><h4 id="搭建环境">搭建环境</h4><h5 id="创建数据库">1. 创建数据库</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database `mybatis`;<br><br>use `mybatis`;<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `<span class="hljs-keyword">user</span>` (<br>  `id` <span class="hljs-type">int</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">primary</span> key,<br>  `name` <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEfault</span> <span class="hljs-keyword">null</span>,<br>  `pwd` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">30</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span><br>) engine<span class="hljs-operator">=</span>innodb <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>` (`id`, `name`, `pwd`) <span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>), <br>(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;李四&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>), <br>(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;王五&#x27;</span>, <span class="hljs-string">&#x27;123890&#x27;</span>); <br></code></pre></td></tr></table></figure><h5 id="创建maven项目并导入maven依赖">2.创建maven项目，并导入maven依赖</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--   mysql驱动   --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.49<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--   mybatis   --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-comment">&lt;!--   junit   --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="创建一个模块module">3. 创建一个模块module</h5><ul><li><h6id="编写mybatis的核心配置文件">编写mybatis的核心配置文件</h6></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--configuration 核心配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="hljs-symbol">&amp;amp;</span>useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;zxc&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><h6 id="编写mybatis工具类">编写mybatis工具类</h6></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisUtils</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用Mybatis第一步： 获取sqlSessionFactory对象</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(resource);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(inputStream);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span><br>    <span class="hljs-comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sqlSessionFactory.openSession();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><h6 id="编写代码">编写代码</h6><ul><li><p>编写实体类</p></li><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserDao</span> &#123;<br>    List&lt;User&gt; <span class="hljs-title function_">getUserList</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接口实现类由原来的***Impl转换为一个Mapper配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.lics.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lics.pojo.User&quot;</span>&gt;</span><br>        select * from mybatis.user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><font color='red'>每一个Mapper.XMl都需要在mybatis的核心配置文件中注册！</font></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/lics/dao/UserMapper.xml&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserDaoTest</span> &#123;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 获取sqlSession对象</span><br>      <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>      <span class="hljs-comment">// 执行SQL</span><br>      <span class="hljs-type">UserDao</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserDao.class);<br>      List&lt;User&gt; userList = mapper.getUserList();<br><br>      System.out.println(userList);<br><br>      sqlSession.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis笔记02</title>
    <link href="/2022/06/12/Mybatis02/"/>
    <url>/2022/06/12/Mybatis02/</url>
    
    <content type="html"><![CDATA[<h3 id="mybatis笔记02">Mybatis笔记02</h3><h4 id="crud">1. CRUD</h4><p>（1）<strong>namespace</strong>:namespace中的包名要和Dao/mapper接口的包名一致！</p><p>（2）<strong>select</strong>: 选择/查询语句；</p><ul><li><p>id：就是对应的namespace中的方法名；</p></li><li><p>resultType: Sql语句执行的返回值</p></li><li><p>parameterType：参数类型</p><p><strong>步骤</strong>：</p></li></ul><ol type="1"><li><p>编写接口</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 根据id查询用户</span><br>User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>;<br></code></pre></td></tr></table></figure></li><li><p>编写对应的mapper中的sql语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.lics.pojo.User&quot;</span>&gt;</span><br>    select * from mybatis.user where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获取sqlSession对象</span><br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MybatisUtils.getSqlSession();<br><br>    <span class="hljs-comment">// 执行SQL</span><br>    <span class="hljs-type">UserMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> mapper.getUserById(<span class="hljs-number">1</span>);<br>    System.out.println(user);<br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>​ （3）增</p><div class="code-wrapper"><pre><code class="hljs">  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.lics.pojo.User&quot;</span>&gt;</span><br>    insert into mybatis.user (id, name, pwd) values<br>    (#&#123;id&#125;, #&#123;name&#125;, #&#123;pwd&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre><p>​ （4）删</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    delete from mybatis.user<br>    where id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ （5）改</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.lics.pojo.User&quot;</span>&gt;</span><br>    update mybatis.user<br>    set name = #&#123;name&#125;, pwd=#&#123;pwd&#125;<br>    where id=#&#123;id&#125;;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong><font color="red">注意：增删改需要提交事务！ </font></strong></p><h4 id="核心配置">2. 核心配置</h4><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。配置文档的顶层结构如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml">configuration（配置）<br>    properties（属性）<br>    settings（设置）<br>    typeAliases（类型别名）<br>    typeHandlers（类型处理器）<br>    objectFactory（对象工厂）<br>    plugins（插件）<br>    environments（环境配置）<br>    environment（环境变量）<br>    transactionManager（事务管理器）<br>    dataSource（数据源）<br>    databaseIdProvider（数据库厂商标识）<br>    mappers（映射器）<br></code></pre></td></tr></table></figure><h5 id="环境配置environments">2.1 环境配置（environments）</h5><p>Mybatis可以配置成适应多种环境</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory实例只能选择一种环境。</strong></p><p>为了指定创建哪种环境，只要将它作为可选的参数传递给SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);<br></code></pre></td></tr></table></figure><p>如果忽略了环境参数，那么将会加载默认环境，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader);<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(reader, properties);<br></code></pre></td></tr></table></figure><p>Mybatis默认的事务管理器：JDBC， 连接池：POOLED</p><h5 id="属性properties">2.2 属性（properties）</h5><p>这些属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java属性文件中配置这些属性，也可以在 properties元素的子元素中设置【db.properties】。</p><p>编写一个配置文件db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">driver</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mybatis?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="hljs-attr">username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">password</span>=<span class="hljs-string">***</span><br></code></pre></td></tr></table></figure><p>也可以在核心配置文件中引入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 引入外部配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;111&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>可以直接引入外部文件</p></li><li><p>可以在<properties> </properties>中增加一些属性配置</p></li><li><p>如果上面两处有同一个字段，优先使用外部文件中的！</p><p>详细说明如下：</p><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis将按照下面的顺序来加载：</p><ul><li>首先读取在 properties 元素体内指定的属性。</li><li>然后根据 properties 元素中的 resource属性读取类路径下属性文件，或根据 url属性指定的路径读取属性文件，并<strong>覆盖</strong>之前读取过的同名属性。</li><li>最后读取作为方法参数传递的属性，并<strong>覆盖</strong>之前读取过的同名属性。</li></ul><p>因此，通过方法参数传递的属性具有最高优先级，resource/url属性中指定的配置文件次之，最低优先级的则是 properties元素中指定的属性。</p></li></ul><h5 id="类型别名typealiases">2.3 类型别名（typeAliases）</h5><p>类型别名可为 Java类型设置一个缩写名字，意在降低冗余的全限定类名书写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.lics.pojo.User&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;User&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以指定一个包名，mybatis会在包名下搜索需要的Java Bean，比如：</p><p>扫描实体类的包，它的默认别名就是这个类的 类名，首字母小写。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.lics.pojo&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="映射器mappers">2.4 映射器（mappers）</h5><p>MapperRegistry: 注册绑定Mapper文件</p><p>方式一：【推荐使用】使用相对于类路径的资源引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/lics/dao/UserMapper.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>方式二：使用class文件绑定注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.lics.dao.UserMapper&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​ 注意点：</p><ul><li>接口和他的Mapper配置文件必须同名，且在同一个包下！</li></ul><p>方式三：使用扫描包进行注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.lics.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意点同方式二。</p><h4 id="生命周期和作用域">3. 生命周期和作用域</h4><p>作用域，和生命周期，是至关重要的，因为错误的使用会导致非常严重的<strong>并发问题</strong>。</p><p><strong>SqlSessionFactoryBuilder</strong></p><ul><li>一旦创建了 SqlSessionFactory，就不再需要它</li><li>局部变量</li></ul><p><strong>SqlSessionFactory</strong>：</p><ul><li>可以想象成数据库连接池</li><li>SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，<strong>没有任何理由丢弃它或重新创建另一个实例</strong>。</li><li>最佳作用域是应用作用域，最简单的就是使用<strong>单例模式</strong>或者静态单例模式</li></ul><p><strong>SqlSession</strong>：</p><ul><li>连接到连接池的一个请求</li><li>SqlSession的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域</li><li>返回一个响应后，就关闭它，否则资源被占用！</li></ul><h4 id="解决类的属性名和数据库中字段名不一致的问题">4.解决类的属性名和数据库中字段名不一致的问题</h4><h6 id="问题">4.1 问题</h6><p>数据库字段：</p><figure><img src="/images/MyBatis/01-dbnames.png" alt="image-dbnames" /><figcaption aria-hidden="true">image-dbnames</figcaption></figure><p>类中属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br>&#125;<br></code></pre></td></tr></table></figure><p>查询出现问题：</p><figure><img src="/images/MyBatis/02-problem-pwdnull.png" alt="image-pwdnull" /><figcaption aria-hidden="true">image-pwdnull</figcaption></figure><p>解决办法：</p><ul><li>起别名（不推荐）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    select id, name, pwd as password from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><strong>resultMap</strong></li></ul><h6 id="resultmap">4.2 resultMap</h6><p>结果集映射</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;UserMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- column：数据库中的字段  property：属性名 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;pwd&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;password&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserList&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;UserMap&quot;</span>&gt;</span><br>    select * from mybatis.user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素</li><li>ResultMap的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用技巧笔记02</title>
    <link href="/2022/06/05/IDEA02/"/>
    <url>/2022/06/05/IDEA02/</url>
    
    <content type="html"><![CDATA[<h3 id="ideawindows使用技巧笔记02">IDEA（windows）使用技巧笔记02</h3><p><font color="red">注：本博客整理的是windows下的IDEA相关的快捷键，MAC等系统可能有所差异。</font></p><h5 id="编写高质量代码">1. 编写高质量代码</h5><table style="width:100%;"><colgroup><col style="width: 15%" /><col style="width: 60%" /><col style="width: 16%" /><col style="width: 8%" /></colgroup><thead><tr class="header"><th>使用场景</th><th>快捷键</th><th style="text-align: left;">说明</th><th>所属菜单</th></tr></thead><tbody><tr class="odd"><td><strong>1. 代码重构</strong></td><td>shift + F6</td><td style="text-align: left;">重构变量名</td><td>Refactor</td></tr><tr class="even"><td></td><td>ctrl + F6<br />(更方便的方式：<br />修改后按 alt + Enter )</td><td style="text-align: left;">重构方法签名</td><td>Refactor</td></tr><tr class="odd"><td><strong>2. 抽取</strong></td><td>ctrl + alt + V</td><td style="text-align: left;">抽取为变量</td><td>Refactor</td></tr><tr class="even"><td></td><td>ctrl + alt + C</td><td style="text-align: left;">抽取为静态变量</td><td>Refactor</td></tr><tr class="odd"><td></td><td>ctrl + alt + F</td><td style="text-align: left;">抽取为成员变量</td><td>Refactor</td></tr><tr class="even"><td></td><td>ctrl + alt + P</td><td style="text-align: left;">抽取为方法参数</td><td>Refactor</td></tr><tr class="odd"><td></td><td>ctrl + alt + M</td><td style="text-align: left;">抽取代码段为方法</td><td>Refactor</td></tr></tbody></table><h5 id="寻找修改轨迹git的集成">2. 寻找修改轨迹（git的集成）</h5><ul><li><p><strong>annotate</strong>：在代码行数上右键可以看到此选项，打开后能看到commit信息、作者等。</p></li><li><p><strong>revert</strong>：撤销，对应快捷键<strong>“ctrl + alt +Z”</strong>，可以对：</p><ul><li>单处修改</li><li>单个文件</li><li>文件夹</li></ul><p>进行撤销操作，回滚到上次提交的状态。</p></li><li><p><strong>local history </strong>: 本地修改记录，通过Help-&gt; FindAction (或快捷键ctrl shift A) 搜索“localhistory”，打开此对话框，可以查看idea的本地的修改记录，即使未使用任何git等版本控制工具，也可以使用。</p></li></ul><h5 id="关联一切待补充">3. 关联一切（待补充）</h5><ul><li><h6 id="与spring的关联">与Spring的关联</h6></li><li><h6 id="与数据库的关联">与数据库的关联</h6></li></ul><h5 id="调试程序">4. 调试程序</h5><table><colgroup><col style="width: 30%" /><col style="width: 30%" /><col style="width: 22%" /><col style="width: 16%" /></colgroup><thead><tr class="header"><th>使用场景</th><th>快捷键</th><th>说明</th><th>所属菜单</th></tr></thead><tbody><tr class="odd"><td><strong>1. 断点调试</strong></td><td>ctrl + F8</td><td>当前行添加断点/删除断点</td><td>Run</td></tr><tr class="even"><td></td><td>shift + F9</td><td>单步调试（Debug模式运行）</td><td>Run</td></tr><tr class="odd"><td></td><td>F8</td><td>单步运行（Step Over，Debug模式下）</td><td></td></tr><tr class="even"><td></td><td>F9</td><td>运行到下一个断点（Resume，Debug模式下，<br />若没有下一个断点则运行至结束）</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>IDEA使用技巧</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda与Stream笔记02--Stream API</title>
    <link href="/2022/06/02/StreamAPINotes01/"/>
    <url>/2022/06/02/StreamAPINotes01/</url>
    
    <content type="html"><![CDATA[<h3id="lambda表达式与stream笔记02--stream-api">Lambda表达式与Stream笔记02--StreamAPI</h3><h4 id="stream-基础知识">Stream 基础知识</h4><ul><li><h5 id="stream的三个操作步骤">Stream的三个操作步骤：</h5><p>（1）创建Stream</p><p>（2）中间操作</p><p>（3）终止操作（终端操作）</p></li><li><h5 id="创建stream的四种方式">创建Stream的四种方式：</h5><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 通过Collection 系列集合提供的 stream() 或 parallelStream()</span><br>      List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      Stream&lt;String&gt; stream1 = list.stream();<br>  <br>      <span class="hljs-comment">// 2. 通过Arrays中的静态方法 stream() 获取数组流</span><br>      String[] strings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>      Stream&lt;String&gt; stream2 = Arrays.stream(strings);<br>  <br>      <span class="hljs-comment">// 3. 通过Stream中的静态方法 of()</span><br>      Stream&lt;String&gt; stream3 = Stream.of(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>, <span class="hljs-string">&quot;cc&quot;</span>);<br>  <br>      <span class="hljs-comment">// 4. 创建无限流</span><br>      <span class="hljs-comment">// (1) 迭代</span><br>      Stream&lt;Integer&gt; stream41 = Stream.iterate(<span class="hljs-number">0</span>, (x) -&gt; x + <span class="hljs-number">2</span>);<br>  <br>      <span class="hljs-comment">// (2) 生成</span><br>      Stream&lt;Double&gt; stream42 = Stream.generate(Math::random);<br></code></pre></td></tr></table></figure></li><li><h5 id="stream-的中间操作">Stream 的中间操作</h5><ul><li><h6 id="惰性求值">惰性求值</h6><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为“惰性求值”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 中间操作： 不会执行任何操作</span><br>      Stream&lt;Employee&gt; stream = employees.stream()<br>              .filter((e) -&gt; &#123;<br>                  System.out.println(<span class="hljs-string">&quot;Stream API 的中间操作&quot;</span>);<br>                  <span class="hljs-keyword">return</span> e.getAge() &gt; <span class="hljs-number">35</span>;<br>              &#125;);<br>    <br>      <span class="hljs-comment">// 终止操作： 一次性执行全部内容，即 “惰性求值”</span><br>      stream.forEach(System.out::println); <span class="hljs-comment">// 若注释此行，不会有任何输出</span><br></code></pre></td></tr></table></figure></li><li><h6 id="筛选与切片">筛选与切片</h6><table><thead><tr class="header"><th>操作</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>fliter</td><td>接收 Lambda ，从流中排除某些元素</td></tr><tr class="even"><td>limit</td><td>截断流，使元素不超过给定数量</td></tr><tr class="odd"><td>skip(n)</td><td>跳过元素，返回一个扔掉了前n个元素的流</td></tr><tr class="even"><td>distinct</td><td>筛选，通过元素的hashcode() 和 equals 去除重复元素</td></tr></tbody></table></li><li><h6 id="映射">映射</h6><table><colgroup><col style="width: 10%" /><col style="width: 89%" /></colgroup><thead><tr class="header"><th>操作</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>map</td><td>接收lambda，将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td></tr><tr class="even"><td>flatMap</td><td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有的流连接成一个流。</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// map</span><br>List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>, <span class="hljs-string">&quot;ccc&quot;</span>, <span class="hljs-string">&quot;ddd&quot;</span>);<br>list.stream()<br>    .map(String::toUpperCase)<br>    .forEach(System.out::println);<br></code></pre></td></tr></table></figure></li><li><h6 id="排序">排序</h6><table><thead><tr class="header"><th>操作</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>sorted</td><td>自然排序</td></tr><tr class="even"><td>sorted(Comparator com)</td><td>定制排序</td></tr></tbody></table></li></ul></li><li><h5 id="stream-的终止操作">Stream 的终止操作</h5><ul><li><h6 id="查找与匹配">查找与匹配</h6><table><thead><tr class="header"><th>操作</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr class="odd"><td>allMatch</td><td>检查是否匹配所有元素</td><td>boolean</td></tr><tr class="even"><td>anyMatch</td><td>检查是否匹配至少一个元素</td><td>boolean</td></tr><tr class="odd"><td>noneMatch</td><td>检查是否没有匹配所有元素</td><td>boolean</td></tr><tr class="even"><td>findFirst</td><td>返回第一个元素</td><td>Optional<T></td></tr><tr class="odd"><td>findAny</td><td>返回当前流中的任意元素</td><td>Optional<T></td></tr><tr class="even"><td>count</td><td>返回流中元素的个数</td><td>Long</td></tr><tr class="odd"><td>max(Comparator com)</td><td>返回流中最大值</td><td>Optional<T></td></tr><tr class="even"><td>min(Comparator com)</td><td>返回流中最小值</td><td>Optional<T></td></tr></tbody></table><p>--Optional容器：操作结果可能为空时，返回Optional容器，解决空指针异常</p></li><li><h6 id="规约">规约</h6><ul><li><p>reduce(T identity, BinaryOperator bo) ---------------不可能为空，因为有初始值 identity， 所以返回 T</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> list.stream()<br>                  .reduce(<span class="hljs-number">0</span>, Integer::sum);<br>System.out.println(sum);<br></code></pre></td></tr></table></figure></li><li><p>reduce(BinaryOperator bo) --------------可能为空，返回Optional</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;Integer&gt; op = list.stream()<br>                           .reduce(Integer::sum);<br>System.out.println(op.get());<br></code></pre></td></tr></table></figure></li></ul></li><li><h6 id="收集">收集</h6><ul><li><p>collect --将流转换成其他形式。接收一个Collector接口的实现，用于给流中的元素做汇总的方法。</p><p>​ --可以使用 Collectors工具类中提供的诸多静态方法获取已实现的收集器。</p><p>Collectors 中常用的收集器：</p><p>toList 、toSet、groupingBy（分组）</p></li></ul></li></ul></li><li><p>并行流与顺序流</p><p>​ 调用 parallel() 方法或 sequential() 切换并行流 或 串行流</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Lambda表达式;Stream API</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Lambda与Stream笔记01--Lambda基础语法</title>
    <link href="/2022/06/02/LambdaNotes01/"/>
    <url>/2022/06/02/LambdaNotes01/</url>
    
    <content type="html"><![CDATA[<h3id="lambda表达式与stream笔记01--lambda基础语法">Lambda表达式与Stream笔记01--Lambda基础语法</h3><h4 id="初体验">初体验</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><pre><code class="hljs java">    List&lt;Employee&gt; employees = Arrays.asList(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-number">3333.33f</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">6666.33f</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">40</span>, <span class="hljs-number">2222.33f</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;赵六&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-number">5500.33f</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;田七&quot;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">7000.33f</span>)<br>    );<br><br>    <span class="hljs-keyword">public</span> List&lt;Employee&gt; <span class="hljs-title function_">filterEmployee</span><span class="hljs-params">(List&lt;Employee&gt; employees, MyPredicate&lt;Employee&gt; myPredicate)</span> &#123;<br>        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Employee e: employees) &#123;<br>            <span class="hljs-keyword">if</span> (myPredicate.test(e)) &#123;<br>                list.add(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">// 匿名内部类</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test01</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Employee&gt; list = filterEmployee(employees, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyPredicate</span>&lt;Employee&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Employee employee)</span> &#123;<br>                <span class="hljs-keyword">return</span> employee.getSalary() &gt;= <span class="hljs-number">5000</span>;<br>            &#125;<br>        &#125;);<br>        list.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-comment">// Lambda表达式</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test02</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Employee&gt; list = filterEmployee(employees, (e) -&gt; e.getSalary() &gt;= <span class="hljs-number">5000</span>);<br>        list.forEach(System.out::println);<br>    &#125;<br><br>    <span class="hljs-comment">// Stream API</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test03</span><span class="hljs-params">()</span> &#123;<br>        employees.stream()<br>                .filter((e) -&gt; e.getSalary() &gt;= <span class="hljs-number">5000</span>)<br><span class="hljs-comment">//                .limit(2)       // 限制输出条数</span><br><span class="hljs-comment">//                .map(Employee::getName)         // 只输出名字</span><br>                .forEach(System.out::println);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="基础语法">基础语法</h4><ul><li><h5 id="箭头操作符lambda操作符--">箭头操作符(Lambda操作符)-&gt;</h5><ul><li>左侧：Lambda 表达式的参数列表</li><li>右侧：Lambda 表达式中所需执行的功能，即Lambda 体</li></ul></li><li><h5 id="语法格式">语法格式</h5><ol type="1"><li><p>无参数，无返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// () -&gt; states;</span><br><span class="hljs-comment">// eg：</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Hello Lambda&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>有一个参数，无返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// eg:</span><br>Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);<br><span class="hljs-comment">// or (只有一个参数时，可以省略小括号，但还是推荐写上)</span><br>Consumer&lt;String&gt; con1 = x -&gt; System.out.println(x);<br></code></pre></td></tr></table></figure></li><li><p>有两个以上参数，有返回值，且Lambda体中有多条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要用大括号将Lambda体括起来</span><br>Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;函数式接口&quot;</span>);<br><span class="hljs-keyword">return</span> Integer.compare(x, y);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Lambda体中只有一条语句，且有返回值：return和大括号都可以省略：</p></li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);<br></code></pre></td></tr></table></figure></p><ol start="5" type="1"><li>Lambda表达式的参数列表的数据类型可以省略不写，因为JVM编译器可以根据上下文推断出数据类型（“类型推断”）。</li></ol></li><li><h5id="lambda表达式需要函数式接口的支持">Lambda表达式需要“函数式接口”的支持</h5><ul><li>函数式接口：接口中只有一个抽象方法时，称为函数式接口。<ul><li>可以使用注解 <span class="citation"data-cites="FunctionalInterface">@FunctionalInterface</span>修饰，以检查是否是函数式接口</li></ul></li></ul></li></ul><h4 id="java8-内置的四大核心函数式接口">Java8内置的四大核心函数式接口</h4><ul><li><p>Consumer<T> ： 消费型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure></li><li><p>Supplier<T> ：供给型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure></li><li><p>Function&lt;T, R&gt; ： 函数型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure></li><li><p>Predicate<T> ： 断言型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">test</span><span class="hljs-params">(T t)</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="方法引用">方法引用</h4><p>​ 若Lambda 体中的内容有方法已经实现了，可以使用“方法引用”</p><ul><li><h5 id="三种语法格式">三种语法格式：</h5><ul><li><p>对象::实例方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; con = System.out::println;<br></code></pre></td></tr></table></figure></li><li><p>类::静态方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; com = Integer::compare;<br></code></pre></td></tr></table></figure></li><li><p>类::实例方法名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">BiPredicate&lt;String, String&gt; bp = String::equals;<br></code></pre></td></tr></table></figure></li></ul></li><li><h5 id="注意事项">注意事项：</h5><ul><li>Lambda体中调用方法的参数列表与返回值类型，要与函数式接口中抽象方法的保持一致</li><li>若Lambda参数列表中的第一个参数是实例方法的调用者，第二个参数是该实例方法的参数时，可以使用语法格式类::实例方法名</li></ul></li></ul><h4 id="构造器引用">构造器引用</h4><ul><li><h5 id="语法格式-1">语法格式：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassName::<span class="hljs-keyword">new</span><br><br><span class="hljs-comment">// eg: (调用的是无参构造函数)</span><br>Supplier&lt;String&gt; sup = String::<span class="hljs-keyword">new</span>;<br><br><span class="hljs-comment">// 调用有参构造函数： 借助 Function接口</span><br>Function&lt;String, String&gt; fun = String::<span class="hljs-keyword">new</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Lambda表达式;Stream API</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL笔记02--开发篇</title>
    <link href="/2022/06/02/MySQLNotes02/"/>
    <url>/2022/06/02/MySQLNotes02/</url>
    
    <content type="html"><![CDATA[<h2 id="深入浅出mysql-开发篇">深入浅出MySQL 开发篇</h2><h3 id="表类型存储引擎的选择">1. 表类型（存储引擎）的选择</h3><h5 id="存储引擎概述">存储引擎概述</h5><p>​插件式存储引擎是MySQL数据库重要特性之一，可根据应用的需要选择如何存储和索引数据、是否使用事务等。MySQL默认支持多种存储引擎，以适应不同领域的db应用需求。</p><p>​ MySQL 5.0 支持的存储引擎：MyISAM, InnoDB, DBD, MEMORY,MERGE,等。其中InnoDB, DBD提供事务安全表，其他都是非事务安全表。</p><p>​ MySQL 5.5 之前的默认存储引擎是MyISAM，5.5 之后改为了InnoDB。</p><h5 id="各种存储引擎的特性">各种存储引擎的特性</h5><h6 id="myisam">1. MyISAM</h6><p>​不支持事务、不支持外键，优势是访问速度快，对事务完整性没有要求或以SELECTINSERT为主的应用可以使用这个引擎创建表。</p><p>​ 每个MyISAM在磁盘上存储成3个文件，其文件名为表名，扩展名分别是</p><ul><li><p>.frm （存储表定义）</p></li><li><p>.MYD （MYData, 存储数据）</p></li><li><p>.MYI （MYIndex, 存储索引）</p><p>MyISAM表还支持3种不同的存储格式：</p></li><li><p>静态（固定长度）表</p></li><li><p>动态表</p></li><li><p>压缩表</p></li></ul><p>​静态表是默认的存储格式，表中字段都是非变长字段，从而每个记录长度固定，优点是存储迅速，容易缓存，出故障易恢复；缺点是占用空间比动态表多。静态表数据在存储时会按列宽定义补足空格，应用访问时空格在返回给应用之前被去掉。​动态表中包含变长字段，记录长度不固定，占用空间少，但频繁地更新和删除记录会产生碎片，需定期执行OPTIMIZETABLE 或 myisamchk-r来改善命令。出故障不易维护。 ​压缩表由myisampack工具创建，占据非常小的磁盘空间。每个记录被单独压缩，只有非常小的访问开支。</p><h6 id="innodb">2. InnoDB</h6><p>​提供了具有提交、回滚和崩溃恢复能力的事务安全。对比MyISAM，InnoDB写的处理效率差一些，并会占用更多的磁盘空间以保留数据和索引。</p><p>​ InnoDB的表的特点：</p><ol type="1"><li><p>自动增长列</p><p>定义方式：col_def auto_increment</p><p>​ eg: create table tname (i smallint not null<strong>auto_increment</strong>)</p><p>设置自动增长列的初始值：ALTER TABLE *** AUTO_INCREMENT = n(默认从1开始)</p><p>查询当前线程最后插入记录使用的值：select LAST_INSERT_ID();</p><p>对于InnoDB，自动增长列<strong>必须是索引</strong>，也必须是<strong>组合索引的第一列</strong>。</p></li><li><p>外键约束</p><ol type="1"><li><p>MySQL支持外键的存储引擎只有InnoDB。在创建外键时，要求父表必须有对应的索引，子表在创建外键时也会自动创建对应的索引。</p></li><li><p>创建索引时，可以指定在删除、更新父表时，对子表进行的相应操作，包括：</p></li></ol><ul><li>RESTRICT：限制在子表有关联记录的情况下父表不能更新</li><li>CASCADE: 父表在更新和删除时，更新或删除子表对应记录</li><li>SET NULL: 父表在更新和删除时，子表对应记录的对应字段被SET NULL</li><li>NO ACTION: 同RESTRICT</li></ul><ol start="3" type="1"><li>当某个表被其他表创建了外键参照，该表的对应索引或主键禁止被删除。</li><li>查看外键信息：show create table 和 show table status</li></ol></li><li><p>存储方式</p><ul><li>使用共享表空间存储，创建的表的表结构存在.frm文件中，数据和索引存在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。</li><li>使用多表空间存储，创建的表的表结构存在.frm文件中，但每个表的数据和索引单独保存在.ibd中。如果是分区表，则每个分区对应单独的.ibd文件，文件名是“表名+分区名”。</li></ul><p>​多表空间的数据文件无大小限制，不需设置初始大小和文件的最大限制、扩展大小等参数。</p></li></ol><h5 id="memory">3. MEMORY</h5><p>​使用存在于内存中的内容创建表。每个MEMORY表只对应一个磁盘文件，格式是.frm。MEMORY表访问非常快，因为数据放在内存中，且默认用HASH索引（创建索引时可以指定为BTREE），但一旦服务关闭，表中数据就会丢掉。</p><p>​服务器需要足够内存维持所有同一时间使用的MEMORY表，当不再需要MEMORY表时，需要执行DELETE或 TRUNCATE TABLE或DROP TABLE释放其占用的内存。</p><p>​MEMORY主要用于内容变化不频繁的代码表，或作为统计操作的中间结果表，便于高效对中间结果进行分析。</p><h5 id="merge">4. MERGE</h5><p>​是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身没有数据，对MERGE表的删改查操作实际是对内部的MyISAM表进行的。对MERGE表的插入操作通过INSERT_METHOD子句定义插入的表。</p><p>​<strong>对MERGE表的DROP操作只是删除MERGE表的定义</strong>，对内部表没有任何影响。</p><p>​ MERGE表 <strong>vs</strong>分区表：MERGE表并不能智能地将记录写到对应的表中，分区表可以。通常使用分区表透明地对多个表进行查询和更新操作。</p><h3 id="合适的数据类型">2. 合适的数据类型</h3><ul><li>对于字符类型，要根据存储引擎进行相应的选择</li><li>对精度要求较高的应用中，建议用定点数存储数值，以保证结果的正确性</li><li>对含有TEXT和BLOB字段的表，如果经常增删记录，要定期执行OPTIMIZETABLE对表进行碎片整理</li><li>日期类型如果要让不同时区的用户使用，最好使用TIMESTAMP，因为日期类型中只有它能和实际时区对应。</li></ul><h3 id="字符集">3. 字符集</h3><ul><li>如果应用需要处理各种文字，或将发布到不同语言的国家地区，应该选择Unicode(对MySQL来说就是UTF-8)字符集。</li><li>如果数据库只需要支持一般中文，数据量大且要求性能，应该选择双字节定长编码的中文字符集，eg：GBK。GBK中每个汉字只占2字节，而UTF-8汉字编码是3字节。<ul><li>如果应用主要处理英文字符，UTF-8更好，因为GBK等的西文编码也是2字节。</li></ul></li><li>如果数据库需要大量的比较、排序等字符运算，那么选择定长字符集处理速度更快。</li></ul><h3 id="索引">4. 索引</h3><p>​所有MySQL列类型都可以被索引。MyISAM和InnoDB的表默认创建的是BTREE索引；MEMORY默认使用HASH索引。</p><h5 id="设计索引的原则">设计索引的原则：</h5><ul><li>最适合索引的列是出现在WHERE子句中的列，或连接子句中指定的列</li><li>使用唯一索引：索引的列的基数（集合里的概念，不同的值的个数）越大，索引效果越好。eg，在出生日期列建索引比在性别（只有两个值）列效果好。</li><li>使用短索引：如果对字符串列进行索引，应尽可能指定一个前缀长度。短索引节省索引空间，也可能使查询更快；此外，对于较短的键值，索引高速缓存中的块能容纳更多键值，增加了找到行而不用读取索引中较多块的可能性。</li><li>利用最左前缀：</li><li>不要过度索引：额外的索引会占用额外磁盘空间，降低写操作的性能。修改表内容时，索引也需要更新甚至重构。</li><li>对于InnoDB的表<ul><li>记录默认按照一定的顺序保存<ul><li>有明确定义的主键：按主键顺序</li><li>无明确定义的主键但有唯一索引：按唯一索引顺序</li><li>都无：自动生成一个内部列，按该列顺序</li></ul></li><li>按照主键或内部列进行访问是最快的，所以InnoDB表尽可能指定主键</li><li>当表中多个列都是唯一时，选最常作为访问条件的列作为主键</li><li>InnoDB表的普通索引也会保存主键的键值，所以主键要尽可能短</li></ul></li></ul><h5 id="btree-索引和hash索引">BTREE 索引和HASH索引</h5><ul><li>HASH索引特点：<ul><li>只用于使用=或&lt;=&gt;操作符的等式比较</li><li>优化器不能使用HASH索引加速ORDER BY</li><li>只能用整个关键字来搜索一行</li></ul></li><li>对于BTREE索引，使用&gt; , &lt; , &gt;= , &lt;= , BETWEEN , != 或者&lt;&gt; , 或者 LIKE（模式不以通配符开始）时，都可以使用相关列上的索引</li></ul><h3 id="视图">5. 视图</h3><p>​视图（view）是一种虚拟存在的表，并不在数据库中实际存在，使用透明。</p><h5 id="视图相对于普通的表优势">视图相对于普通的表优势：</h5><ul><li>简单：用户无需关心后面对应的表结构、关联条件、筛选条件，对用户来说是过滤好的复合条件的结果集。</li><li>安全：用户只能访问被允许查询的结果集</li><li>数据独立：一旦视图结构确定，可以屏蔽表结构变化对用户的影响</li></ul><h5 id="视图操作">视图操作</h5><ul><li><p>创建或修改视图</p><p>创建视图需要有CREATE VIEW 权限，并对查询涉及的列有SELECT权限。若使用CREATE OR REPLACE或ALTER修改视图，还需要视图的DROP权限。</p><p>创建视图语法：</p><p>CREATE [OR REPLACE]</p><p>​ VIEW vname [(col_list)]</p><p>​ AS select_statement</p><p>修改视图语法：</p><p>ALTER</p><p>​ VIEW vname [(col_list)]</p><p>​ AS select_statement</p></li><li><p>删除视图</p><p>DROP VIEW [IF EXISES] vname</p></li><li><p>查看视图</p><p>MySQL 5.1开始 SHOW TABLES [STATUS]同时会显示视图信息。</p></li></ul><h3 id="存储过程和函数">6. 存储过程和函数</h3><p>​存储过程和函数是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可以简化工作，减少数据在数据库和应用服务器之间的传输，利于提高数据处理效率。</p><p>​存储过程和函数的区别在于函数必须有返回值，而存储过程没有，存储过程的参数可以使用IN,OUT, INOUT类型，函数的参数只能是IN。</p><h5 id="相关权限">相关权限</h5><ul><li>创建：需要CREATE ROUTINE 权限</li><li>修改或删除：需要ALTER ROUTINE 权限</li><li>执行：需要EXECUTE 权限</li></ul><h5 id="创建or修改存储过程和函数">创建or修改存储过程和函数</h5><p>CREATE PROCEDURE sp_name ([proc_param]) ​ [characteristic]routine_body</p><p>CREATE FUNCTION sp_name ([func_param]) ​ RETURNS type ​[characteristic] routine_body</p><h5 id="调用">调用</h5><p>CALL sp_name ([proc_param])</p><h5 id="存储过程的好处">存储过程的好处</h5><p>​处理逻辑封装在数据库端，调用者不需要了解中间的处理逻辑，一旦处理逻辑发生改变，只需要修改存储过程，而对调用者的程序完全没有影响。</p><h3 id="触发器">7. 触发器</h3><p>​触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。可以协助应用在数据库端确保数据的完整性。</p><h5 id="创建触发器">创建触发器</h5><p>CREATE TRIGGER trigger_name trigger_time trigger_event</p><p>ON tb1_name FOR EACH ROW trigger_stmt</p><p>触发器只能创建在永久表上， 不能对临时表创建触发器。</p><ul><li>trigger_time ：触发时间，可以是<ul><li>BEFORE , 在检查约束前触发</li><li>AFTER , 在检查约束后触发</li></ul></li><li>trigger_event：触发事件，可以是增删改</li></ul><p>对同一个表相同触发时间的相同触发事件，只能定义一个触发器。</p><p><strong>可以使用别名OLD和NEW来引用触发器中发生变化的记录内容。</strong></p><h5 id="触发顺序">触发顺序</h5><ul><li>对于有重复记录、需要进行UPDATE 操作的INSERT,触发器触发的顺序是BEFOREINSERT -&gt; BEFORE UPDATE -&gt; AFTER UPDATE;</li><li>对于没有重复记录的INSERT,就是简单执行INSERT, 触发顺序是BEFORE INSERT-&gt; AFTER INSERT</li><li><strong>对实际执行UPDATE 操作的记录，仍会执行BEFOREINSERT触发器的内容</strong></li></ul><h3 id="事务控制和锁定语句">8. 事务控制和锁定语句</h3><p>​默认情况下，表锁和行锁都是自动获得的，不需要额外命令。但是在有的情况下，用户需要明确进行锁表或进行事务的控制，以确保事务的完整性。</p><h5 id="lock-table-与-unlock-table">LOCK TABLE 与 UNLOCK TABLE</h5><ul><li>LOCK TABLES锁定用于当前线程的表，如果表被其他线程锁定，则当前线程会等待，直到可以获取所有锁定为止</li><li>UNLOCK TABLES 释放当前线程获得的任何锁定</li></ul><h5 id="事务控制">事务控制</h5><p>​ 默认情况下，MySQL是自动提交的。</p><ul><li>START TRANSACTION 或BEGIN 开始一项新的事务</li><li>COMMIT 和 ROLLBACK 用来提交或回滚事务</li><li>CHAIN 和 RELEASE 子句分别定义事务提交或回滚之后的操作，<ul><li>CHAIN 会立即启动一个新事务，并和刚才的事务有相同的隔离级别；</li><li>RELEASE 会断开和客户端的连接</li></ul></li><li>SET AUTOCOMMIT (=0)修改当前连接的提交方式，设为0时之后的所有事务都需要明确的命令进行提交或回滚。</li></ul><p><strong>如果在锁表期间，用start transaction开始一个新事务，会隐含执行unlock tables</strong></p><h3 id="sql中的安全问题">9. SQL中的安全问题</h3><h5 id="sql注入">SQL注入</h5><h3 id="mysql-分区">10. MySQL 分区</h3><p>​分区是指根据一定的规则，数据库把一个表分解成多个更小的、更容易管理的部分。对于访问数据库的应用来说，逻辑上只有一个表或一个索引，实际上这个表可能有数10个物理分区对象组成，每个分区都是一个独立对象，可以独自处理，可以作为表的一部分处理。分区对于应用来说是完全透明的，不影响应用的业务逻辑。</p><h5 id="分区的优点">分区的优点</h5><ul><li>和单个磁盘或文件系统相比，可以存储更多数据</li><li>优化查询。在Where子句中包含分区条件时，可以只扫描必要的一个或多个分区来提高查询效率；同时在涉及SUM和COUNT这类聚合函数的查询时，可以容易地在每个分区上并行处理，最终只需要汇总所有分区得到的结果</li><li>对于已经过期或不需要保存的数据，可以删除与这些数据有关的分区来快速删除数据</li><li>跨多个磁盘分散数据查询，以获得更大的查询吞吐量</li></ul><h5 id="分区概述">分区概述</h5><p>​分区有利于管理非常大的表，采用了分治逻辑，分区引入了分区键的概念。分区键用于根据某个区间值、特定值列表、HASH函数值执行数据的聚集，让数据根据规则分布在不同的分区中。</p><h5 id="分区类型">分区类型</h5><ul><li>RANGE分区：基于一个给定连续区间范围，把数据分配到不同分区</li><li>LIST分区：基于枚举出的值列表分区</li><li>HASH分区：基于给定的分区个数，分配数据</li><li>KEY分区：类似HASH分区</li></ul><p><strong>注意</strong>：无论哪种分区类型，都不能用主键/唯一键字段之外的其他字段分区</p><h5 id="range分区">Range分区</h5><p>利用取值范围将数据分成分区，区间要连续且不能互相重叠，使用VALUES LESSTHAN进行分区的定义。</p><p><strong>注意</strong>：每个分区都按顺序进行定义，从最低到最高。</p><p>可以使用VALUES LESS THANMAXVALUE子句提供给所有大于明确指定的最高值的值。</p><p>特别适用于：</p><ul><li>需要删除过期数据，eg：ALTER TABLE tname DROP PARTITION p0</li><li>经常运行包含分区键的查询</li></ul><h5 id="list-分区">List 分区</h5><p>建立离散的值列表告诉数据库特定的值属于哪个分区。</p><p>使用PARTITION BY LIST + VALUES IN (X,X)</p><p>LIST 分区不需要声明任何特定的顺序。</p><p>若试图插入的列值不包含在分区值列表中时，INSERT会失败并报错。</p><h5 id="columns分区">Columns分区</h5><p>可以细分为RANGE Columns和LISTColumns分区，都支持整数、日期时间、字符串三大数据类型。</p><p>Columns分区还支持多列分区。</p><h5 id="hash分区">Hash分区</h5><p>主要用来分散热点读，确保数据在预先确定个数的分区中尽可能平均分布。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>深入浅出MySQL笔记01--基础篇</title>
    <link href="/2022/06/02/MySQLNotes01/"/>
    <url>/2022/06/02/MySQLNotes01/</url>
    
    <content type="html"><![CDATA[<h2 id="深入浅出mysql-基础篇">深入浅出MySQL 基础篇</h2><h3 id="sql基础">1. SQL基础</h3><h5 id="sql分类">SQL分类</h5><ol type="1"><li>DDL语句：数据定义语言，定义不同的数据段、数据库、表、列、索引等数据库对象，常用关键字：create，drop，alter；</li><li>DML语句：数据操纵语句，增删改查以及检查数据完整性，常用关键字：insert，delete，update，select；</li><li>DCL语句：数据控制语句，控制不同数据段直接的许可和访问级别，定义了访问权限和安全级别，主要关键字：grant，revoke。</li></ol><h5 id="查看表定义">查看表定义</h5><ol type="1"><li><p>DESC tname</p></li><li><p>show create table tname ---- 可以看到存储引擎和字符集等信息</p><p>​ 使得记录能按字段竖向排列</p></li></ol><h5 id="修改表">修改表</h5><ol type="1"><li><p>修改表类型：ALTER TABLE tname MODIFY col_def [FIRST | AFTERcol_name]</p><p>​ col_def ：列定义，包含 col_name col_type [约束]</p></li><li><p>增加表字段：ALTER TABLE tname ADD col_def [FIRST | AFTERcol_name]</p></li><li><p>删除表字段：ALTER TABLE tname DROP col_name</p></li><li><p>字段改名：ALTER TABLE tname CHANGE old_col_name col_def [FIRST |AFTER col_name]</p><p>​ change <strong>vs</strong>modify：都可以修改表的列定义，但change可以修改列名称。另外，change需要写两遍列名，只需要修改列类型时，用modify。</p></li><li><p>修改字段排列顺序：FIRST | AFTER col_name</p><p>​ 上述124语句，ADD新增的字段默认在表最后，CHANGE &amp; MODIFY默认不改变字段位置。</p><p>​ FIRST ：将该列置于表最前</p><p>​ AFTER col_name： 将该列置于col_name列后</p></li><li><p>更改表名： ALTER TABLE tname RENAME new_tname</p></li></ol><h5 id="查询表">查询表</h5><ol type="1"><li><p>查询不重复记录：distinct</p></li><li><p>排序：order by，默认升序，desc降序</p></li><li><p>限制：limit，配合order by进行分页显示</p><p>​ limit offset_start, row_count</p></li><li><p>聚合：</p><ol type="1"><li><p>语法：</p><p><em>SELECT [field] fun_name</em></p><p><em>FROM tname</em></p><p><em>[WHERE condition]</em></p><p><em>[GROUP BY field1, field2, ..., fieldn]</em></p><p><em>[WITH ROLLUP]</em></p><p><em>[HAVING condition]</em></p></li><li><p>说明：</p><p>fun_name: 聚合函数，sum、count(*)、max、min</p><p>GROUP BY：要进行聚合得字段</p><p>WITH ROLLUP： 可选，是否对分类聚合后的结果进行再汇总</p><p>HAVING ：对分类后的结果再进行条件的过滤</p><p><strong><em>注</em></strong>：HAVING <strong>vs</strong> WHERE：HAVING 是对聚合后的结果进行条件的过滤，WHERE是聚合前对记录进行过滤。</p></li></ol></li><li><p>表连接：</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li>左连接</li><li>右连接</li></ul></li></ul></li><li><p>子查询：</p><p>​ in、=（子查询记录数唯一）；</p><p>​ 表连接很多情况下优于子查询。</p></li><li><p>记录联合：</p><p>​ union（会对结果进行distinct）、unionall（把结果直接合并在一起）</p></li></ol><h3 id="mysql支持的数据类型">2. MySQL支持的数据类型</h3><ol type="1"><li><p>CHAR、VARCHAR</p><p>​ 检索时，CHAR列会删除尾部的空格，而VARCHAR会保留</p></li><li><p>BINARY</p><p>​保存的是ascii码的16进制表示，且会在值的最后填充“0x00”达到指定的长度</p></li><li><p>ENUM 、 SET</p><p>​ ENUM ：</p><ul><li>忽略大小写；</li><li>插入不在ENUM 指定范围内的值时，会插入范围内的第一个值；</li><li>只允许取单个值 ​ SET</li><li>一次可以取多个成员</li><li>对超出允许值范围的值，不允许注入</li><li>对于包含重复成员的集合只取一次，eg. （'a,d,a'）-&gt; ('a,d')</li></ul></li></ol><h3 id="mysql中的运算符">3. MySQL中的运算符</h3><h5 id="比较运算符">比较运算符</h5><ol type="1"><li><p>不等于：&lt;&gt;、!=</p></li><li><p>&lt;=&gt;: null安全的等于</p><p>​ null = null ---------- null</p><p>​ null &lt;&gt; null ---------- null</p><p>​ null &lt;=&gt; null ---------- 1</p></li></ol><h5 id="逻辑运算与null">逻辑运算与null</h5><ul><li>not null ---------- null</li><li>1 and null ---------- null （and操作数中任何一个为null，返回值为null）</li><li>or<ul><li>1 or null ---------- 1</li><li>0 or null ---------- null</li><li>null or null ---------- null</li></ul></li><li>xor : 操作数中任何一个为null，返回值为null</li></ul><h5 id="位运算">位运算</h5><p>​位取反：MySQL中常量数字默认以8个字节存储，对1（63个前导0）取反会得到非常大的数</p><h3 id="常用函数">4. 常用函数</h3><h5 id="字符串函数">字符串函数</h5><h5 id="img"><img src="/images/MySQL/01_stringFunc.png"alt="img" /></h5><ol type="1"><li><p>LPAD、RPAD “指定的长度len”为填充后的总长度</p><p>LPAD(str, len,padstr)：在str的左边填充给定的字符padstr到指定的长度len，返回填充后的字符串</p><p>RPAD(str, len,padstr)：在str的右边填充给定的字符padstr到指定的长度len，返回填充后的字符串</p></li></ol><h5 id="数值函数">数值函数</h5><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>ABS(x)</td><td>返回x的绝对值</td></tr><tr class="even"><td>BIN(x)</td><td>返回x的二进制（OCT返回八进制，HEX返回十六进制）</td></tr><tr class="odd"><td>CEILING(x)</td><td>返回大于x的最小整数值</td></tr><tr class="even"><td>EXP(x)</td><td>返回值e（自然对数的底）的x次方</td></tr><tr class="odd"><td>FLOOR(x)</td><td>返回小于x的最大整数值</td></tr><tr class="even"><td>GREATEST(x1,x2,...,xn)</td><td>返回集合中最大的值</td></tr><tr class="odd"><td>LEAST(x1,x2,...,xn)</td><td>返回集合中最小的值</td></tr><tr class="even"><td>LN(x)</td><td>返回x的自然对数</td></tr><tr class="odd"><td>LOG(x,y)</td><td>返回x的以y为底的对数</td></tr><tr class="even"><td>MOD(x,y)</td><td>返回x/y的模（余数）</td></tr><tr class="odd"><td>PI()</td><td>返回pi的值（圆周率）</td></tr><tr class="even"><td>RAND()</td><td>返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值</td></tr><tr class="odd"><td>ROUND(x,y)</td><td>返回参数x的四舍五入的有y位小数的值</td></tr><tr class="even"><td>SIGN(x)</td><td>返回代表数字x的符号的值</td></tr><tr class="odd"><td>SQRT(x)</td><td>返回一个数的平方根</td></tr><tr class="even"><td>TRUNCATE(x,y)</td><td>返回数字x截短为y位小数的结果</td></tr></tbody></table><h5 id="流程函数">流程函数</h5><ul><li><p>if(value,t,f) : 如果value是真,返回t;否则返回f</p></li><li><p>ifnull(value1,value2) :如果valve1不为空则返回value1,否则返回value2</p><ul><li>一般在处理含null值的列的数值运算时，用此函数替换null值</li></ul></li><li><p>case when [value1]</p><p>then [result]...else[defalult]END：如果value1是真,返回result1,否则返回defalut</p></li><li><p>case [expr ] when [value1]</p><p>then[result]...else[default]END ：如果expr等于value1,返回result,否则返回defalut</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架笔记03--Map;Collections工具类</title>
    <link href="/2022/06/02/JavaCollectionNotes03/"/>
    <url>/2022/06/02/JavaCollectionNotes03/</url>
    
    <content type="html"><![CDATA[<h3 id="java集合框架笔记03">Java集合框架笔记03</h3><h4 id="map-体系">Map 体系</h4><div data-align="center"><p><img src="/images/JavaCollectionNotes/02_Map.png" width="200px" height="240px" style="center"/>`</p></div><ul><li><h5 id="map特点">Map特点</h5><p>（1）存储任意键值对</p><p>（2）键：无序、无下标、不允许重复（唯一）</p><p>（3）值：无序、无下标、允许重复</p></li><li><h5 id="遍历方法">遍历方法</h5><ul><li><p>keySet</p></li><li><p>entrySet （效率高于keySet）</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 添加元素</span><br>map.put(<span class="hljs-string">&quot;cn&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>);<br>map.put(<span class="hljs-string">&quot;uk&quot;</span>, <span class="hljs-string">&quot;英国&quot;</span>);<br>map.put(<span class="hljs-string">&quot;usa&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>);<br><span class="hljs-comment">// map.put(&quot;cn&quot;, &quot;zhongguo&quot;); 会覆盖 “中国” 的值</span><br><br><span class="hljs-comment">// 遍历--两种方式：（1） keySet （2）entrySet</span><br>System.out.println(<span class="hljs-string">&quot;====使用 keySet 遍历====&quot;</span>);<br><span class="hljs-keyword">for</span> (String key: map.keySet()) &#123;<br>    System.out.println(key + <span class="hljs-string">&quot;-----------&quot;</span> + map.get(key));<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;====使用 entrySet 遍历====&quot;</span>);<br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry:  map.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;-----------&quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="map-实现类">Map 实现类</h4><h5 id="hashmap">HashMap</h5><ul><li><h5 id="属性">属性</h5><table><colgroup><col style="width: 4%" /><col style="width: 25%" /><col style="width: 6%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th>属性</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">1</td><td>DEFAULT_INITIAL_CAPACITY</td><td>16</td><td>默认初始容量</td></tr><tr class="even"><td style="text-align: left;">2</td><td>DEFAULT_LOAD_FACTOR</td><td>0.75f</td><td>默认加载因子（达到容量的75%以后，进行扩容）</td></tr><tr class="odd"><td style="text-align: left;">3</td><td>TREEIFY_THRESHOLD</td><td>8</td><td>桶链表长度大于此值后，（且数组长度大于64---见&lt;5&gt;），将链表调整成树</td></tr><tr class="even"><td style="text-align: left;">4</td><td>UNTREEIFY_THRESHOLD</td><td>6</td><td>树的元素个数小于6时，调整回链表</td></tr><tr class="odd"><td style="text-align: left;">5</td><td>MIN_TREEIFY_CAPACITY</td><td>64</td><td>&lt;3&gt;中树化的另一个条件</td></tr></tbody></table></li><li><h5 id="总结">总结</h5><p>（1）HashMap刚创建时，table是null（节省空间），添加第一个元素时，table容量调整为16</p><p>（2）当元素个数大于阈值（cap*0.75）时，会进行扩容，容量变为原来的2倍（2倍：减少调整元素的个数）</p><p>（3）jdk1.8：</p><ul><li><p>当每个链表长度大于8，且数组元素个数大于64时，调整为红黑树，目的是提高执行效率</p></li><li><p>当链表长度小于6时，调整成链表</p></li></ul><p>（4）jdk1.8以前，链表是头插入，jdk1.8以后是尾插入</p><p>（5）线程不安全，运行效率快；允许用null作为key或value</p></li></ul><h5 id="hashtable">Hashtable</h5><ul><li>线程安全，运行效率慢；不允许null作为key或value</li></ul><h5 id="properties">Properties</h5><ul><li>Hashtable的子类，要求key、value都是String。通常用于配置文件的读取。</li></ul><h5 id="treemap">TreeMap</h5><ul><li>实现了SortedMap接口，可以对key自动排序</li></ul><h4 id="collections工具类">Collections工具类</h4><p>包含很多操作集合的静态方法。</p><p>（1）sort、binarySearch、reverse、shuffle、copy等</p><h4 id="集合数组相互转换">集合、数组相互转换</h4><ul><li><p>数组转集合后，得到的是受限集合，不能添加和删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] names = &#123;<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>&#125;;<br>List&lt;String&gt; nameList = Arrays.asList(names);<br><span class="hljs-comment">// nameList.add(&quot;赵六&quot;);    // 报错：java.lang.UnsupportedOperationException</span><br>System.out.println(nameList);<br></code></pre></td></tr></table></figure></li><li><p>把基本类型的数组转成集合时，需要修改为包装类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;;<br>List&lt;<span class="hljs-type">int</span>[]&gt; list = Arrays.asList(nums);     <span class="hljs-comment">// 返回类型：数组 的列表</span><br>Integer[] nums2 = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>, <span class="hljs-number">400</span>, <span class="hljs-number">500</span>&#125;;<br>List&lt;Integer&gt; integers = Arrays.asList(nums2);    <span class="hljs-comment">// 返回类型：包装类  Integer的列表</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架笔记01--Collection基础概念; List及实现类</title>
    <link href="/2022/06/02/JavaCollectionNotes01/"/>
    <url>/2022/06/02/JavaCollectionNotes01/</url>
    
    <content type="html"><![CDATA[<h3 id="java集合框架笔记01">Java集合框架笔记01</h3><h4 id="基础概念">基础概念</h4><ul><li>集合： 对象的容器，实现了对 对象 常用的操作，类似数组的功能。</li><li>集合与数组的区别：<ul><li>数组长度固定，集合长度不固定。</li><li>数组可以存储基本类型和引用类型，集合只能存储引用类型</li></ul></li></ul><h4 id="collection体系集合">Collection体系集合</h4><ul><li><h5 id="collection体系集合框架">Collection体系集合框架：</h5><p><img src="/images/JavaCollectionNotes/01_Collection.png" width="600px" height="300px" style="center"/>`</p></li><li><h5 id="collection父接口">Collection父接口</h5><ul><li><h6 id="方法">方法：</h6><ul><li>boolean add(E e) // 添加一个元素</li><li>boolean addAll(Collection c) // 将集合c中的所有元素添加到此集合</li><li>void clear() // 清空集合中的所有元素</li><li>boolean contains(Object o) // 检查集合中是否包含o元素</li><li>boolean containsAll(Collection c) //检查集合中是否包含c中所有元素</li><li>boolean equals(Object obj) // equals</li><li>boolean isEmpty() // 判断集合是否为空集合</li><li>boolean remove(Object o) // 移除o元素</li><li>boolean removeAll(Collection c) //移除也包含在集合c中的所有元素</li><li>boolean retainAll(Collection c) //相当于交集，仅此集合中保留也包含在c中的元素</li><li>int size() // 返回集合中的元素的个数</li><li>Object[] toArray() // 将集合转换成数组</li></ul></li><li><h6 id="遍历collection">遍历Collection：</h6><ul><li><p>增强for （for-each）</p></li><li><p>迭代器（Iterator）</p><p>（1）有三个方法：</p><ul><li>hasNext(); // 有没有下一个元素</li><li>next(); // 获取下一个元素</li><li>remove(); // 删除一个元素</li></ul><p>（2）使用迭代器遍历集合的典型代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> collection.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (String) it.next();<br>    System.out.println(s);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * !!! 不允许遍历过程中使用Collection中的其他方法改变集合中的元素 !!!</span><br><span class="hljs-comment">     * 否则将抛出“ConcurrentModificationException” 并发修改异常</span><br><span class="hljs-comment">     * 但可以使用迭代器中的remove()方法删除元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// collection.remove(s);    // 不允许！ 抛出ConcurrentModificationException异常</span><br>    <span class="hljs-comment">// it.remove();             // 允许</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ul></li></ul></li><li><h5 id="list子接口">List子接口</h5><ul><li><h6 id="特点">特点：</h6><p>有序、有下标、元素可重复</p></li><li><h6 id="方法-1">方法：</h6><p>包含Collection父接口中的全部方法，并包含以下方法：</p><ul><li>void add(int index, E element) // 将元素插入指定位置</li><li>boolean addAll(int index, Collection c) //将c中的所有元素插入到此集合的指定位置</li><li>E get(int index) // 获取指定位置的元素</li><li>List subList(int fromIndex, int toIndex) // 截取部分列表</li><li>indexOf(Object o) // 获取o第一次出现的位置</li><li>lastIndexOf(Object o) //</li><li>remove(int index)</li></ul></li><li><h6 id="遍历方式">遍历方式：</h6><p>可以使用for、增强for、迭代器遍历</p></li><li><h6 id="listiterator">ListIterator：</h6><p>比Collection的Iterator功能更强大，既可以前向遍历，又可以后向遍历，还可以在遍历过程中添加、修改或删除元素。</p><p>​ 包含以下方法：</p><ul><li>void add(E e) // 将e插入list</li><li>boolean hasNext()<br /></li><li>boolean hasPrevious()</li><li>E next() // 返回下一个元素并移动游标</li><li>int nextIndex() // 返回下个元素的下标</li><li>E previous()</li><li>int previousIndex()</li><li>void remove() // 删除上一次调用next或previous返回的元素</li><li>void set(E e) // 修改上一次调用next或previous返回的元素</li></ul></li></ul></li><li><h5 id="list的实现类">List的实现类：</h5><ul><li>ArrayList<ul><li>数组结构实现，查询快、增删慢</li><li>运行效率快、线程不安全</li></ul></li><li>Vector<ul><li>数组结构实现，查询快、增删慢</li><li>运行效率慢、线程安全</li></ul></li><li>LinkedList<ul><li>链表结构实现，增删快、查询慢</li></ul></li></ul></li><li><h5 id="arraylist-源码分析">ArrayList 源码分析</h5><p>​ DEFAULT_CAPACITY = 10 默认容量大小</p><p>​ --如果没有像集合中添加任何元素时，容量是0；添加一个元素之后，容量是10</p><p>​ elementData 存放元素的数组</p><p>​ size 实际元素个数</p><p>​ add方法，在数组容量不够时，扩容为原来的1.5倍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="linkedlist-源码分析">LinkedList 源码分析</h5><p>基于双向链表</p><p>int size 集合大小</p><p>Node first 链表的头节点</p><p>Node last 链表的尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>    last = newNode;<br>    <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        l.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架笔记02--泛型;Set</title>
    <link href="/2022/06/02/JavaCollectionNotes02/"/>
    <url>/2022/06/02/JavaCollectionNotes02/</url>
    
    <content type="html"><![CDATA[<h3 id="java集合框架笔记02">Java集合框架笔记02</h3><h4 id="泛型">泛型</h4><ul><li><h5 id="基本概念">基本概念</h5><ul><li><p>本质：参数化类型，把类型作为参数传递</p></li><li><p>常见形式：泛型类、泛型接口、泛型方法</p></li><li><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs java">&lt;T, ...&gt;     <span class="hljs-comment">// T称为类型占位符，表示一种引用类型</span><br></code></pre></td></tr></table></figure></li><li><p>好处：</p><p>（1）提高代码的重用性</p><p>（2）防止类型转换异常，提高代码的安全性</p></li><li><p>注意点：</p><p>（1）泛型只能 使用引用类型</p><p>（2）不同泛型对象之间不能相互赋值</p></li></ul></li><li><h5 id="泛型类的继承">泛型类的继承</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&lt;T1, T2&gt; &#123;<br>&#125;<br><br><span class="hljs-comment">// 子类不保留父类的泛型</span><br><span class="hljs-comment">// （1）没有类型  擦除</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span>&lt;A, B&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123; <br>    <span class="hljs-comment">// 等价于  class Son extends Father&lt;Object, Object&gt;</span><br>&#125;<br><br><span class="hljs-comment">// （2）具体类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>&lt;A, B&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&lt;Integer, String&gt; &#123;<br>&#125;<br><br><span class="hljs-comment">// 子类保留父类的泛型</span><br><span class="hljs-comment">// （1）全部保留</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&lt;T1, T2&gt;&#123;<br>&#125;<br><br><span class="hljs-comment">// （2）部分保留</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son4</span>&lt;T2, A, B&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&lt;Integer, T2&gt;&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><h5 id="泛型在继承方面的体现">泛型在继承方面的体现</h5><ul><li><p>类A是类B的父类，但G<A>和G<B>二者不具备子父类关系，二者是并列关系</p><ul><li>G<A>和G<B>二者共同的父类是G&lt;?&gt; --------- ?为通配符</li></ul></li><li><p>类（接口）A是类B的父类（接口），A<G>是B<G>的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractList&lt;String&gt; list1 = <span class="hljs-literal">null</span>;<br>List&lt;String&gt; list2 = <span class="hljs-literal">null</span>;<br>ArrayList&lt;String&gt; list3 = <span class="hljs-literal">null</span>;<br>list1 = list3;      <span class="hljs-comment">// 允许</span><br>list2 = list3;      <span class="hljs-comment">// 允许</span><br></code></pre></td></tr></table></figure></li><li><p>使用通配符后的访问要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list1.add(<span class="hljs-string">&quot;AA&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;BB&quot;</span>);<br>list1.add(<span class="hljs-string">&quot;CC&quot;</span>);<br><br>List&lt;?&gt; list2 = list1;<br><br><span class="hljs-comment">// 添加（写入）：对于List&lt;?&gt;不能向其内部添加数据</span><br><span class="hljs-comment">// 除了添加null之外。</span><br><span class="hljs-comment">//list2.add(&quot;AA&quot;);       // 编译报错</span><br>list2.add(<span class="hljs-literal">null</span>);         <span class="hljs-comment">// 允许</span><br><br><span class="hljs-comment">// 读取：允许读取数据，读取的数据类型为Object</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list2.get(<span class="hljs-number">0</span>);<br>System.out.println(o);<br></code></pre></td></tr></table></figure></li><li><p>有限制条件的通配符的使用</p><ul><li>? ： （-∞, +∞）</li><li>? extends Father: （-∞, Father]</li><li>? super Father : [Father, +∞）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        ?   ： （-∞, +∞）</span><br><span class="hljs-comment">        ? extends Father: （-∞, Father]</span><br><span class="hljs-comment">        ? super Father  :  [Father, +∞）</span><br><span class="hljs-comment">         */</span><br><br>        List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&gt; list1 = <span class="hljs-literal">null</span>;<br>        List&lt;? <span class="hljs-built_in">super</span> Father&gt; list2 = <span class="hljs-literal">null</span>;<br><br>        List&lt;Student&gt; list3 = <span class="hljs-literal">null</span>;<br>        List&lt;Father&gt; list4 = <span class="hljs-literal">null</span>;<br>        List&lt;Object&gt; list5 = <span class="hljs-literal">null</span>;<br><br>        list1 = list3;<br>        list1 = list4;<br>        <span class="hljs-comment">// list1 = list5;   //不允许</span><br><br>        <span class="hljs-comment">// list2 = list3;   //不允许</span><br>        list2 = list4;<br>        list2 = list5;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="泛型集合">泛型集合</h4><ul><li><h5 id="基本概念-1">基本概念</h5><ul><li>参数化类型、类型安全的集合，强制集合元素的类型必须一致。</li><li>特点：<ul><li>编译时即可检查，而非运行时抛出异常。</li><li>访问时，不必类型转换。</li><li>不同泛型之间引用不能相互赋值，泛型不存在多态。</li></ul></li></ul></li></ul><h4 id="set">Set</h4><ul><li><h5 id="基本概念-2">基本概念</h5><ul><li>特点：无序、无下标、元素不可重复</li><li>方法：全部继承自Collection中的方法</li></ul></li><li><h5 id="遍历方式">遍历方式</h5><ul><li>增强for</li><li>迭代器</li></ul></li></ul><h4 id="set-的实现类">Set 的实现类</h4><ul><li><h5 id="hashset">HashSet</h5><ul><li>基于HashCode计算元素的存放位置</li><li>当存入元素的哈希码相同时，调用equals确认，如果结果为true，拒绝后者存入</li><li>存储结构：哈希表（数组+链表+红黑树）</li></ul></li><li><h5 id="treeset">TreeSet</h5><ul><li>基于排列顺序实现元素不重复</li><li>实现了SortedSet接口，对集合元素自动排序</li><li>元素对象的类型必须实现Comparable接口，指定排序的规则<ul><li>通过该接口中的CompareTo方法确定是否为重复元素</li></ul></li><li>存储结构：红黑树</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java集合框架</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IDEA使用技巧笔记01</title>
    <link href="/2022/06/02/IDEA01/"/>
    <url>/2022/06/02/IDEA01/</url>
    
    <content type="html"><![CDATA[<h3 id="ideawindows使用技巧笔记01">IDEA（windows）使用技巧笔记01</h3><p><font color="red">注：本博客整理的是windows下的IDEA相关的快捷键，MAC等系统可能有所差异。</font></p><h5 id="窗口跳转">1. 窗口跳转</h5><p>（1）快捷键：<strong>alt + 数字</strong></p><p>（2）可以设置显示窗口编号：</p><p><img src="/images/IDEA/01_show_tools_numbers.png" width="800px" height="600px" style="center"/></p><p>​设置后，各工具窗口会显示其对应的数字编号，想跳转到某个窗口时，就可以按下“alt+相应的数字键”。</p><p><img src="/images/IDEA/02_tools_windows_ex.png" width="80px" height="300px" style="center"/></p><h5 id="跳转相关的快捷键">2. 跳转相关的快捷键</h5><table><colgroup><col style="width: 18%" /><col style="width: 18%" /><col style="width: 43%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th>使用场景</th><th>快捷键</th><th style="text-align: left;">说明</th><th>所属菜单</th></tr></thead><tbody><tr class="odd"><td><strong>1. 项目之间跳转</strong></td><td>ctrl + alt + ]</td><td style="text-align: left;">跳转到下个项目</td><td>Window</td></tr><tr class="even"><td></td><td>ctrl + alt + [</td><td style="text-align: left;">跳转到上个项目</td><td>Window</td></tr><tr class="odd"><td><strong>2. 文件之间跳转</strong></td><td>ctrl + E</td><td style="text-align: left;">打开最近查看的文件（Recent Files）</td><td>View</td></tr><tr class="even"><td></td><td>ctrl + shift + E</td><td style="text-align: left;">打开最近编辑的文件（Recently ChangedFiles）</td><td>View</td></tr><tr class="odd"><td></td><td>ctrl + shift + Backspace<br />（<strong>or鼠标侧键</strong>）</td><td style="text-align: left;">跳转到上次编辑的地方（Last EditLocation）</td><td>Navigate</td></tr><tr class="even"><td></td><td><br />（<strong>or鼠标侧键</strong>）</td><td style="text-align: left;">跳转到下次编辑的地方（Last EditLocation）</td><td>Navigate</td></tr><tr class="odd"><td></td><td>（ctrl+）alt + 左键头</td><td style="text-align: left;">跳转到下次浏览的地方（Forward）</td><td>Navigate</td></tr><tr class="even"><td></td><td>（ctrl+）alt + 右键头</td><td style="text-align: left;">跳转到上次浏览的地方（Back）</td><td>Navigate</td></tr><tr class="odd"><td>利用标签跳转<br />浏览源码等场景</td><td>F11</td><td style="text-align: left;">添加/删除书签</td><td></td></tr><tr class="even"><td></td><td>ctrl + F11</td><td style="text-align: left;">添加带助记符号的书签</td><td></td></tr><tr class="odd"><td></td><td>ctrl + 数字键</td><td style="text-align: left;">带助记符号的标签之间的跳转</td><td></td></tr><tr class="even"><td>收藏位置和文件</td><td>双击Favourites窗口<br />中的书签列表<br /><img src="/images/IDEA/03_bookmarks.png" width="200px" height="180px" style="center"/></td><td style="text-align: left;">也可以跳转到书签对应的代码位置</td><td></td></tr><tr class="odd"><td><strong>3. 编辑区和文件区<br />之间的跳转</strong></td><td>alt + 1</td><td style="text-align: left;">代码编辑区跳转到文件区</td><td></td></tr><tr class="even"><td></td><td>Esc</td><td style="text-align: left;">文件区跳转到代码编辑区</td><td></td></tr></tbody></table><h5 id="快速定位代码">3. 快速定位代码</h5><table><colgroup><col style="width: 18%" /><col style="width: 18%" /><col style="width: 43%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th>使用场景</th><th>快捷键</th><th style="text-align: left;">说明</th><th>所属菜单</th></tr></thead><tbody><tr class="odd"><td><strong>精准搜索</strong></td><td>ctrl + N</td><td style="text-align: left;">定位类</td><td>Navigate</td></tr><tr class="even"><td></td><td>ctrl + shift + N</td><td style="text-align: left;">定位文件</td><td>Navigate</td></tr><tr class="odd"><td></td><td>ctrl + alt + shift + N</td><td style="text-align: left;">定位符号<br />（符号：方法名/属性）</td><td>Navigate</td></tr><tr class="even"><td></td><td>ctrl + shift +F<br />(若无效，可能是跟windows<br />自带的输入法的简繁体<br />切换快捷键冲突，关闭之。)</td><td style="text-align: left;">定位字符串。<br />相关选项：<br />Cc:区分大小写<br />W: 单词匹配<br />.*：正则表达式匹配<br />File mask:在指定的文件类型中查找</td><td>Edit</td></tr></tbody></table><h5 id="代码小助手">4. 代码小助手</h5><table><colgroup><col style="width: 18%" /><col style="width: 18%" /><col style="width: 43%" /><col style="width: 18%" /></colgroup><thead><tr class="header"><th>使用场景</th><th>快捷键</th><th style="text-align: left;">说明</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><strong>1. 移动光标与选择</strong></td><td>shift + 右箭头</td><td style="text-align: left;">选中下一个字符</td><td><em>小结：大部分移动光标的快捷键，<br />加上shift可以进行选中</em></td></tr><tr class="even"><td></td><td>ctrl + 右箭头</td><td style="text-align: left;">移动光标到单词结束位置</td><td></td></tr><tr class="odd"><td></td><td>ctrl + shift + 右箭头</td><td style="text-align: left;">选中到单词结束位置</td><td></td></tr><tr class="even"><td></td><td>Home</td><td style="text-align: left;">移动光标到行首</td><td></td></tr><tr class="odd"><td></td><td>ctrl + alt + shift + J</td><tdstyle="text-align: left;">批量选中操作<br />需要先选中一个符号/变量</td><td></td></tr><tr class="even"><td><strong>2. 代码模板</strong><br />（非快捷键）</td><td>live templates</td><tdstyle="text-align: left;">可以自定义一些<br />类似psvm的代码模板，<br />减少敲重复代码</td><td></td></tr><tr class="odd"><td></td><td>postfix completion</td><td style="text-align: left;">常用：<br />- for 循环<br />- nn判断非空<br />- return 返回<br />- field 创建类中的属性</td><td></td></tr><tr class="even"><td><strong>3. 万能神器</strong></td><td>alt + Enter</td><td style="text-align: left;">遇事不决，alt Enter</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>IDEA使用技巧</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
